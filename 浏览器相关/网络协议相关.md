### ip 协议

```
通过ip协议可以把数据包发送到目标主机上面，（给数据包添加ip地址）
```

### udp

```
作用：通过udp协议可以把已经传动到目标主机上的数据包发送到对应端口的应用上（给数据包添加端口号）

缺点：1：没有丢包重试机制 ，会有数据包丢失的问题
      2: 传输的数据包没有重新组装的机制，数据包无法还原原本大的数据文件
```

### tcp

```
作用： 同upd协议一样
对比udp的优点：1：具有丢包重传机制 2：数据包具有排序机制，保证数据包组成一个完整的文件

tcp/http 的三次握手和四次挥手
三握
客户端发送连接的请求
服务端收到并发送确认可以连接的请求
客户端接收到服务端发送确认可以连接的请求，并告知服务端自己收到了

四挥
1：客户端发送需要断开连接的请求
2：服务端收到断开连接的请求，并发送自己收到了断开连接的请求给客户端
3：服务端做好了断开连接请求的准备，并发送请求通知客户端，断开连接准备完成，可以断开连接了
4：客户端收到服务端可以断开连接的请求后，发送断开连接的

连接终止
```

### 浏览器地址栏中输入一个网页地址之后，浏览器会执行哪些动作

```
1:构建请求，生成一个请求行信息，（内容包括，请求方法-uri-协议）
2：查找缓存，如果之前访问过并且缓存没有过期，直接读取缓存响应请求
3：准备ip和端口号，没有命中缓存，则需要通过dns解析url 对应的ip和端口号（为ip协议和tcp协议处理数据包做准备），dns解析过的域名地址会被浏览器缓存起来，下次访问时直接读取缓存
4：判断是否需要等待tpc链接，谷歌最多有6个tpc链接，如果超了就排队，等队列中其他tcp连接结束之后建立tcp连接
5：建立tcp连接 （三次挥手）
6：发送http请求（个人理解这个阶段就是数据传输的过程）
  1：先发送请求行请求方法、请求URI（Uniform Resource Identifier）和HTTP版本协议。
  2：发送请求头
7: 发送请求成功等待服务器响应


服务器响应成功之后，经过ip层和tcp层拿到数据包，进行数据整合
拿到html数据流 解析为dom树，中间碰到js脚本停下来先加载执行js脚本，加载js脚本之前会先加载样式文件css,解析css文件生成cssom，然后执行js脚本，根据脚本是async还是defer 判断脚本加载完成后是立即执行还是等待html解析完dom之后执行

然后根据生成的dom树和cssom树生成渲染树render tree 进行相应的重排和重绘操作

至此一个url在浏览器中输入地址之后浏览器执行了哪些动作就完成了
```

## 总结：从输入 URL 到页面展示，这中间发生了什么

> https://blog.poetries.top/browser-working-principle/guide/part1/lesson04.html#%E6%80%BB%E7%BB%93%EF%BC%9A%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88

```
用户输入url并回车

浏览器进程检查url，组装协议，构成完整的url

浏览器进程通过进程间通信（IPC）把url请求发送给网络进程

网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程

如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：

进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
利用ip地址和服务器建立tcp连接
构建请求头信息
发送请求头信息
服务器响应后，网络进程接收响应头和响应信息，并解析响应内容

网络进程解析响应流程；
检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步 （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
准备渲染进程
浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
传输数据、更新状态
渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
渲染进程接收完数据后，向浏览器发送“确认提交”
浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面
```

### 个人理解版本

```
一:用户在输入框输入内容按下回车键后，浏览器进程会根据用户输入的信息判断是完整的url链接还是搜索内容，如果是搜索内容在使用默认搜索引擎进程处理，否则会通过ipc把url请求交给网络进程处理
二：网络进程拿到url地址后
  先检查是否本地存在缓存，有缓存则利用缓存响应
  没有缓存则进行http请求，请求流程：
    1：通过dns对域名解析获取服务器ip地址
    2：拿到ip地址后和服务器建立tcp连接
    3：网络进程生成请求头 请求行信息发送请求
    4：服务器收到请求后响应，生成响应行响应头响应体数据返回
    5：网络进程收到响应内容后进行解析
  网络进程解析服务器响应体内容流程如下：
    1：检查响应状态码 如果为301/302 根据location 自动跳转，开始重复二的步骤操作
    2：响应状态为200，解析响应数据内容，
      如果为html，网络进程会通知浏览器进程准备渲染进程进行渲染
      如果是字节流类型则交给下载管理器，当前导航流程结束
三：浏览器进程创建好渲染进程后
  1：给渲染进程发送，提交文档的消息，渲染进程然后和网络进程建立数据传输管道，读取响应数据
  2：渲染进程接受完数据后，向浏览器进程发送确认提交的消息
  3：浏览器进程收到消息后，更新浏览器界面状态：安全状态，地址栏地址，前进后退记录，web页面内容
```

> 为什么需要三次握手，两次不行吗？

```
其实这是由TCP的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力,第二次握手，服务端SYN=1,Seq=Y就确认了发送能力,ACK=X+1就确认了接收能力,所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。
```
